{"version":15,"variables":[{"key":"Job","type":"query","visible":true,"input":"fetch logs\n| filter matchesPhrase(content, \"JOBS\") AND  matchesPhrase(content, \"RunID\")\n| parse content , \"\nLD 'JOBS.' WORD:Job\nLD 'RunID ' STRING:RunId\nLD:status\"\n| fields Job\n| dedup Job\n| append [data record(Job=\"All\")]\n| limit 10000\n","multiple":true,"defaultValue":["All"]},{"key":"Status","type":"csv","visible":true,"input":"Completed without errors,Started,Failed,Running,All","multiple":true,"defaultValue":["All"]}],"tiles":{"0":{"type":"code","title":"Batch Job DQL with JS","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nfunction utcToLocal(utcTimestamp) {\n  const date = new Date(utcTimestamp);\n  return date.toLocaleString(); // This converts to local timezone\n}\n\n\nexport default async function () {\n  const timeout = 60;\n\n  // Query to pull batchJob data\n  const query = `fetch logs,scanLimitGBytes: -1, from:\"${$dt_timeframe_from}\",to:\"${$dt_timeframe_to}\"\n| filter matchesPhrase(content, \"JOBS\") AND  matchesPhrase(content, \"RunID\")\n| parse content , \"\nLD 'JOBS.' WORD:Job\nLD 'RunID ' STRING:RunId\nLD:status\"\n| fields timestamp, Job, status, content, RunId\n| filterOut status == \".\"\n| fieldsAdd start_time=if(contains(content,\"started.\"),timestamp)\n| fieldsAdd end_time=if(contains(content,\"ended normally.\"),timestamp)\n| fields timestamp, content, Job, status, RunId,start_time,end_time`;\n  \n  console.log(query);\n  try {\n    const response = await queryExecutionClient.queryExecute({ \n      body: { \n        query, \n        requestTimeoutMilliseconds: timeout * 1000, \n        fetchTimeoutSeconds: timeout \n      } \n    });\n    \n    const recordSet = response.result.records;\n    //console.log(recordSet);\n\n    const batch = {};\n    const statusLocked = {}; // Lock the status once I find exit return for a runId\n\n    for (const record of recordSet) {\n      const runId = record['RunId'];\n      let status = record[\"status\"]?.trim() || \"\";\n      console.log(`RunId: ${runId}, Raw status: ${status}`);\n\n      if (!batch[runId]) {\n        batch[runId] = {\n          Job: record[\"Job\"],\n          run_id: runId,\n          Status: \"\",\n          JobStarted: null,\n          JobEnded: null,\n          Duration: \"NA\"\n        };\n        statusLocked[runId] = false;\n      }\n\n      if (record[\"start_time\"]) batch[runId].JobStarted = utcToLocal(record[\"start_time\"]);\n      if (record[\"end_time\"]) batch[runId].JobEnded = utcToLocal(record[\"end_time\"]);\n      \n      // Update status field for runId only if it's not locked\n      if (!statusLocked[runId]) {\n        if (status.toLowerCase().includes(\"ended with return code\")) {\n          batch[runId].Status = \"Failed\";\n          statusLocked[runId] = true;\n        } else if (status) {\n          if (status == \"started.\") {\n            batch[runId].Status = \"Running\";\n          }\n          else if (status == \"ended normally.\") {\n            batch[runId].Status = \"Completed without errors\";\n            statusLocked[runId] = true;\n          }\n          else {\n            batch[runId].Status = status;\n          }\n        }\n      }\n    }\n\n    for (const runId in batch) {\n      const job = batch[runId];\n      if (job.JobStarted && job.JobEnded) {\n        const startTime = new Date(job.JobStarted);\n        const endTime = new Date(job.JobEnded);\n        const duration = endTime - startTime;        \n        job.Duration = `${duration / 1000} seconds`;        \n      }\n    }\n    \n    const batchList = Object.values(batch);\n    console.log(\"Final batch list:\", batchList);\n    return batchList;\n  } catch (error) {\n    console.error(\"An error occurred:\", error);\n    throw error;\n  }\n}\n\n","visualization":"table","visualizationSettings":{"thresholds":[{"id":1,"field":"Status","title":"","isEnabled":true,"rules":[{"id":0,"color":{"Default":"var(--dt-colors-charts-logstatus-none-default, #2c2f3f)"},"comparator":"=","label":"","value":"Completed without errors"},{"id":1,"color":{"Default":"var(--dt-colors-charts-loglevel-emergency-default, #9033a3)"},"comparator":"=","label":"","value":"Failed"},{"id":2,"color":{"Default":"var(--dt-colors-charts-categorical-color-09-default, #649438)"},"comparator":"=","label":"","value":"Running"}]}],"chartSettings":{"xAxisScaling":"analyzedTimeframe","gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxisLabel":"Job","valueAxisLabel":"","categoryAxis":"Job","valueAxis":[],"tooltipVariant":"single"},"truncationMode":"middle"},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","recordField":"element","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{"[\"Job\"]":273.25,"[\"Status\"]":270.6875,"[\"JobStarted\"]":224.65625,"[\"JobEnded\"]":220.65625},"colorThresholdTarget":"background","sortBy":{"columnId":"[\"Duration\"]","direction":"ascending"}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"Job"},"displayedFields":["run_id"],"colorMode":"color-palette","colorPalette":"categorical"},"histogram":{"dataMappings":[]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"1":{"type":"code","title":"","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nfunction utcToLocal(utcTimestamp) {\n  const date = new Date(utcTimestamp);\n  return date.toLocaleString();\n}\n\nexport default async function () {\n  const timeout = 60;\n  \n  // Converting the MgmtZone from Array to json String\n  let JobString = [];\n  let JobArr = $Job;\n        \n  for (let i = 0; i < JobArr.length; i++) {\n    JobString.push(JSON.stringify(JobArr[i]));\n  }\n  console.log(\"Job:\",JobString);\n  \n  let StatusString = [];\n  let StatusArr = $Status;\n        \n  for (let i = 0; i < StatusArr.length; i++) {\n    StatusString.push(JSON.stringify(StatusArr[i]));\n  }\n  console.log(\"Job:\",JobString);\n  // Query to pull batchJob data\n  const query = `fetch logs, scanLimitGBytes: -1, from:\"${$dt_timeframe_from}\",to:\"${$dt_timeframe_to}\"\n| filter matchesPhrase(content, \"JOBS\") AND  matchesPhrase(content, \"RunID\")\n| parse content , \"\nLD 'JOBS.' WORD:Job\nLD 'RunID ' STRING:RunId\nLD:status\"\n| fields timestamp, Job, status, content, RunId\n| filterOut status == \".\"\n| filter in(` + JobString + `,\"All\") OR in(Job,` + JobString + `)\n| fieldsAdd start_time=if(contains(content,\"started.\"),timestamp)\n| fieldsAdd end_time=if(contains(content,\"ended normally.\"),timestamp)\n| fields timestamp, content, Job, status, RunId,start_time,end_time`;\n  \n  console.log(query);\n  try {\n    const response = await queryExecutionClient.queryExecute({ \n      body: { \n        query, \n        requestTimeoutMilliseconds: timeout * 1000, \n        fetchTimeoutSeconds: timeout \n      } \n    });\n    \n    const recordSet = response.result.records;\n    console.log(recordSet);\n\n    const batch = {};\n    const statusLocked = {}; // Lock the status once I find exit return for a runId\n\n    for (const record of recordSet) {\n      const runId = record['RunId'];\n      let status = record[\"status\"]?.trim() || \"\";\n      console.log(`RunId: ${runId}, Raw status: ${status}`);\n\n      if (!batch[runId]) {\n        batch[runId] = {\n          Job: record[\"Job\"],\n          run_id: runId,\n          Status: \"\",\n          JobStarted: null,\n          JobEnded: null,\n          Duration: \"NA\"\n        };\n        statusLocked[runId] = false;\n      }\n\n      if (record[\"start_time\"]) batch[runId].JobStarted = utcToLocal(record[\"start_time\"]);\n      if (record[\"end_time\"]) batch[runId].JobEnded = utcToLocal(record[\"end_time\"]);\n      \n      // Update status field for runId only if it's not locked\n      if (!statusLocked[runId]) {\n        if (status.toLowerCase().includes(\"ended with return code\")) {\n          batch[runId].Status = \"Failed\";\n          statusLocked[runId] = true;\n        } else if (status) {\n          if (status == \"started.\") {\n            batch[runId].Status = \"Running\";\n          }\n          else if (status == \"ended normally.\") {\n            batch[runId].Status = \"Completed without errors\";\n            statusLocked[runId] = true;            \n          }\n          else {\n            batch[runId].Status = status;\n          }\n        }\n      }\n    }\n\n    for (const runId in batch) {\n      const job = batch[runId];\n      if (job.JobStarted && job.JobEnded) {\n        const startTime = new Date(job.JobStarted);\n        const endTime = new Date(job.JobEnded);\n        const duration = endTime - startTime;        \n        job.Duration = `${duration / 1000} seconds`;        \n      }\n    }\n    \n    if (!StatusArr.includes(\"All\")) {\n      const batchList = Object.values(batch).filter(job => StatusArr.includes(job.Status));  \n      return batchList;\n    }\n    else {\n      const batchList = Object.values(batch);\n      return batchList;\n\n    }\n  } catch (error) {\n    console.error(\"An error occurred:\", error);\n    throw error;\n  }\n}\n\n","visualization":"table","visualizationSettings":{"thresholds":[{"id":1,"field":"Status","title":"","isEnabled":true,"rules":[{"id":0,"color":{"Default":"var(--dt-colors-charts-categorical-color-09-default, #649438)"},"comparator":"=","label":"","value":"Running"},{"id":1,"color":{"Default":"var(--dt-colors-charts-logstatus-none-default, #2c2f3f)"},"comparator":"=","label":"","value":"Completed without errors"},{"id":2,"color":{"Default":"var(--dt-colors-charts-categorical-color-12-default, #cd3741)"},"comparator":"=","label":"","value":"Failed"}]}],"chartSettings":{"xAxisScaling":"analyzedTimeframe","gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxis":"Job","categoryAxisLabel":"Job","valueAxis":[],"valueAxisLabel":"","tooltipVariant":"single"},"truncationMode":"middle"},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","recordField":"element","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{},"colorThresholdTarget":"background","sortBy":{"columnId":"[\"Status\"]","direction":"ascending"}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"Status"},"displayedFields":["run_id"],"colorMode":"color-palette","colorPalette":"categorical"},"histogram":{"dataMappings":[]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"2":{"type":"markdown","title":"","content":"---  \n## Tiles based on selected Job & Status filters. Select multiple values for the filters or \"All\" (for bypassing filter)ðŸ‘‡  \n---\n"},"3":{"type":"code","title":"Job by status","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nexport default async function () {\n  const timeout = 60;\n  \n  // Converting the MgmtZone from Array to json String\n  let JobString = [];\n  let JobArr = $Job;\n        \n  for (let i = 0; i < JobArr.length; i++) {\n    JobString.push(JSON.stringify(JobArr[i]));\n  }\n  console.log(JobString);\n  \n  // Query to pull batchJob data\n  const query = `fetch logs,scanLimitGBytes: -1, from:\"${$dt_timeframe_from}\",to:\"${$dt_timeframe_to}\"\n| filter matchesPhrase(content, \"JOBS\") AND  matchesPhrase(content, \"RunID\")\n| parse content , \"\nLD 'JOBS.' WORD:Job\nLD 'RunID ' STRING:RunId\nLD:status\"\n| fields timestamp, Job, status, content, RunId\n| filterOut status == \".\"\n| filter in(` + JobString + `,\"All\") OR in(Job,` + JobString + `)\n| fieldsAdd start_time=if(contains(content,\"started.\"),timestamp)\n| fieldsAdd end_time=if(contains(content,\"ended normally.\"),timestamp)\n| fields timestamp, content, Job, status, RunId,start_time,end_time`;\n  \n  console.log(query);\n  try {\n    const response = await queryExecutionClient.queryExecute({ \n      body: { \n        query, \n        requestTimeoutMilliseconds: timeout * 1000, \n        fetchTimeoutSeconds: timeout \n      } \n    });\n    \n    const recordSet = response.result.records;\n    //console.log(recordSet);\n\n    const batch = {};\n    const statusLocked = {}; // Lock the status once I find exit return for a runId\n\n    for (const record of recordSet) {\n      const runId = record['RunId'];\n      let status = record[\"status\"]?.trim() || \"\";\n      console.log(`RunId: ${runId}, Raw status: ${status}`);\n\n      if (!batch[runId]) {\n        batch[runId] = {\n          Job: record[\"Job\"],\n          run_id: runId,\n          Status: \"\",\n          JobStarted: null,\n          JobEnded: null,\n          Duration: \"NA\"\n        };\n        statusLocked[runId] = false;\n      }\n\n      if (record[\"start_time\"]) batch[runId].JobStarted = record[\"start_time\"];\n      if (record[\"end_time\"]) batch[runId].JobEnded = record[\"end_time\"];\n      \n      // Update status field for runId only if it's not locked\n      if (!statusLocked[runId]) {\n        if (status.toLowerCase().includes(\"ended with return code\")) {\n          batch[runId].Status = \"Failed\";\n          statusLocked[runId] = true;\n        } else if (status) {\n          if (status == \"started.\") {\n            batch[runId].Status = \"Started\";\n          }\n          else if (status == \"ended normally.\") {\n            batch[runId].Status = \"Completed without errors\";\n            statusLocked[runId] = true;            \n          }\n          else {\n            batch[runId].Status = status;\n          }\n        }\n      }\n    }\n\n    for (const runId in batch) {\n      const job = batch[runId];\n      if (job.JobStarted && job.JobEnded) {\n        const startTime = new Date(job.JobStarted);\n        const endTime = new Date(job.JobEnded);\n        const duration = endTime - startTime;        \n        job.Duration = `${duration / 1000} seconds`;        \n      }\n    }\n    \n    const batchList = Object.values(batch);\n    const jobStatusCount = {\n      Started: 0,\n      \"Completed without errors\": 0,\n      Failed: 0,\n      Other: 0\n    };\n\n    // Count the jobs by status\n    for (const job of batchList) {\n      switch (job.Status) {\n        case \"Started\":\n          jobStatusCount.Started++;\n          break;\n        case \"Completed without errors\":\n          jobStatusCount[\"Completed without errors\"]++;\n          break;\n        case \"Failed\":\n          jobStatusCount.Failed++;\n          break;\n        default:\n          jobStatusCount.Other++;\n    }\n  }\n    \n  const pieChartData = Object.entries(jobStatusCount).map(([status, count]) => ({\n    label: status,\n    value: count\n  }));\n  return pieChartData;\n    \n  } catch (error) {\n    console.error(\"An error occurred:\", error);\n    throw error;\n  }\n}\n\n","visualization":"donutChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative","showTotalValue":true},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxis":"label","valueAxis":"value","categoryAxisLabel":"label","valueAxisLabel":"value","tooltipVariant":"single"},"colorPalette":"swamps","truncationMode":"middle"},"singleValue":{"showLabel":true,"label":"No. of Jobs","prefixIcon":"","recordField":"element","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"value"},"displayedFields":["label"],"colorMode":"color-palette","colorPalette":"blue"},"histogram":{"dataMappings":[{"valueAxis":"value","rangeAxis":""}]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"4":{"type":"code","title":"Median duration of completed Jobs (seconds)","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nexport default async function () {\n  const timeout = 60;\n  \n  // Converting the MgmtZone from Array to json String\n  let JobString = [];\n  let JobArr = $Job;\n        \n  for (let i = 0; i < JobArr.length; i++) {\n    JobString.push(JSON.stringify(JobArr[i]));\n  }\n  console.log(JobString);\n  \n  // Query to pull batchJob data\n  const query = `fetch logs,scanLimitGBytes: -1, from:\"${$dt_timeframe_from}\",to:\"${$dt_timeframe_to}\"\n| filter matchesPhrase(content, \"JOBS\") AND  matchesPhrase(content, \"RunID\")\n| parse content , \"\nLD 'JOBS.' WORD:Job\nLD 'RunID ' STRING:RunId\nLD:status\"\n| fields timestamp, Job, status, content, RunId\n| filterOut status == \".\"\n| filter in(` + JobString + `,\"All\") OR in(Job,` + JobString + `)\n| fieldsAdd start_time=if(contains(content,\"started.\"),timestamp)\n| fieldsAdd end_time=if(contains(content,\"ended normally.\"),timestamp)\n| fields timestamp, content, Job, status, RunId,start_time,end_time`;\n  \n  console.log(query);\n  try {\n    const response = await queryExecutionClient.queryExecute({ \n      body: { \n        query, \n        requestTimeoutMilliseconds: timeout * 1000, \n        fetchTimeoutSeconds: timeout \n      } \n    });\n    \n    const recordSet = response.result.records;\n    //console.log(recordSet);\n\n    const batch = {};\n    const statusLocked = {}; // Lock the status once I find exit return for a runId\n\n    for (const record of recordSet) {\n      const runId = record['RunId'];\n      let status = record[\"status\"]?.trim() || \"\";\n      console.log(`RunId: ${runId}, Raw status: ${status}`);\n\n      if (!batch[runId]) {\n        batch[runId] = {\n          Job: record[\"Job\"],\n          run_id: runId,\n          Status: \"\",\n          JobStarted: null,\n          JobEnded: null,\n          Duration: \"NA\"\n        };\n        statusLocked[runId] = false;\n      }\n\n      if (record[\"start_time\"]) batch[runId].JobStarted = record[\"start_time\"];\n      if (record[\"end_time\"]) batch[runId].JobEnded = record[\"end_time\"];\n      \n      // Update status field for runId only if it's not locked\n      if (!statusLocked[runId]) {\n        if (status.toLowerCase().includes(\"ended with return code\")) {\n          batch[runId].Status = \"Failed\";\n          statusLocked[runId] = true;\n        } else if (status) {\n          if (status == \"started.\") {\n            batch[runId].Status = \"Started\";\n          }\n          else if (status == \"ended normally.\") {\n            batch[runId].Status = \"Completed without errors\";\n            statusLocked[runId] = true;\n          }\n          else {\n            batch[runId].Status = status;\n          }\n        }\n      }\n    }\n\n    for (const runId in batch) {\n      const job = batch[runId];\n      if (job.JobStarted && job.JobEnded) {\n        const startTime = new Date(job.JobStarted);\n        const endTime = new Date(job.JobEnded);\n        const duration = endTime - startTime;        \n        job.Duration = `${duration / 1000} seconds`;        \n      }\n    }\n    \n    const batchList = Object.values(batch);\n\n\nconst jobDurations = [];\nfor (const job of batchList) {\n  if (job.Duration !== \"NA\") {\n    const duration = parseFloat(job.Duration.split(' ')[0]);\n    jobDurations.push(duration);\n  }\n}\n\n// Function to calculate median\nfunction calculateMedian(arr) {\n  const sorted = arr.sort((a, b) => a - b);\n  const middle = Math.floor(sorted.length / 2);\n\n  if (sorted.length % 2 === 0) {\n    return ((sorted[middle - 1] + sorted[middle]) / 2).toFixed(2);\n  }\n\n  return sorted[middle].toFixed(2);\n}\n\n// Calculate median duration\nlet medianDuration = jobDurations.length > 0 ? calculateMedian(jobDurations) : \"N/A\";\nreturn (medianDuration);\n    \n  } catch (error) {\n    console.error(\"An error occurred:\", error);\n    throw error;\n  }\n}\n\n","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"xAxisScaling":"analyzedTimeframe","gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative","showTotalValue":true},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxisLabel":"element","valueAxisLabel":"","categoryAxis":"element","valueAxis":[],"tooltipVariant":"single"},"colorPalette":"swamps","truncationMode":"middle"},"singleValue":{"showLabel":false,"label":"Median duration of completed jobs","prefixIcon":"","recordField":"element","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"element"},"displayedFields":["element"],"colorMode":"color-palette","colorPalette":"categorical"},"histogram":{"dataMappings":[]},"unitsOverrides":[{"identifier":"element","unitCategory":"angle","baseUnit":"second","displayUnit":null,"decimals":2,"suffix":"","delimiter":false,"added":1721661614847}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"5":{"type":"markdown","title":"","content":"---  \n## Complete data dump ðŸ‘‡\n---\n"},"6":{"type":"code","title":"Duration median for different Jobs","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nexport default async function () {\n  const timeout = 60;\n\n  // Query to pull batchJob data\n  const query = `fetch logs, from:\"${$dt_timeframe_from}\",to:\"${$dt_timeframe_to}\"\n| filter matchesPhrase(content, \"JOBS\") AND  matchesPhrase(content, \"RunID\")\n| parse content , \"LD 'JOBS.' WORD:Job LD 'RunID ' STRING:RunId LD:status\"\n| fields timestamp, Job, status, content, RunId\n| fieldsAdd start_time=if(contains(content,\"started.\"),timestamp)\n| fieldsAdd end_time=if(contains(content,\"ended normally.\"),timestamp)\n| fields timestamp, content, Job, status, RunId,start_time,end_time`;\n  \n  console.log(query);\n  try {\n    const response = await queryExecutionClient.queryExecute({ \n      body: { \n        query, \n        requestTimeoutMilliseconds: timeout * 1000, \n        fetchTimeoutSeconds: timeout \n      } \n    });\n    \n    const recordSet = response.result.records;\n    //console.log(recordSet);\n\n    const batch = {};\n    const statusLocked = {}; // Lock the status once I find exit return for a runId\n\n    for (const record of recordSet) {\n      const runId = record['RunId'];\n      let status = record[\"status\"]?.trim() || \"\";\n      console.log(`Job: ${record[\"Job\"]}, RunId: ${runId}, Raw status: ${status}`);\n\n      if (!batch[runId]) {\n        batch[runId] = {\n          Job: record[\"Job\"],\n          run_id: runId,\n          Status: \"\",\n          JobStarted: null,\n          JobEnded: null,\n          Duration: \"NA\"\n        };\n        statusLocked[runId] = false;\n      }\n\n      if (record[\"start_time\"]) batch[runId].JobStarted = record[\"start_time\"];\n      if (record[\"end_time\"]) batch[runId].JobEnded = record[\"end_time\"];\n      \n      // Update status field for runId only if it's not locked\n      if (!statusLocked[runId]) {\n        if (status.toLowerCase().includes(\"ended with return code\")) {\n          batch[runId].Status = \"Failed\";\n          statusLocked[runId] = true;\n        } else if (status) {\n          if (status == \"started.\") {\n            batch[runId].Status = \"Running\";\n          }\n          else if (status == \"ended normally.\") {\n            batch[runId].Status = \"Completed without errors\";\n            statusLocked[runId] = true;\n          }\n          else {\n            batch[runId].Status = status;\n          }\n        }\n      }\n    }\n\n    for (const runId in batch) {\n      const job = batch[runId];\n      if (job.JobStarted && job.JobEnded) {\n        const startTime = new Date(job.JobStarted);\n        const endTime = new Date(job.JobEnded);\n        const duration = endTime - startTime;        \n        job.Duration = `${duration / 1000} seconds`;        \n      }\n    }\n\n  const jobDurations = {};\n\n  for (const runId in batch) {\n    const job = batch[runId];\n    if (job.JobStarted && job.JobEnded) {\n      const startTime = new Date(job.JobStarted);\n      const endTime = new Date(job.JobEnded);\n      const duration = (endTime - startTime) / 1000; // Duration in seconds\n      \n      if (!jobDurations[job.Job]) {\n        jobDurations[job.Job] = [];\n      }\n      jobDurations[job.Job].push(duration);\n    }\n  }\n\n  const medianDurations = {};\n  for (const jobType in jobDurations) {\n    const durations = jobDurations[jobType].sort((a, b) => a - b);\n    const mid = Math.floor(durations.length / 2);\n    const median = durations.length % 2 === 0\n      ? (durations[mid - 1] + durations[mid]) / 2\n      : durations[mid];\n    medianDurations[jobType] = median;\n  }\n\n  // Prepare data for pie chart\n  const pieChartData = Object.entries(medianDurations).map(([jobType, duration]) => ({\n    Job: jobType,\n    Duration_in_seconds: Math.round(duration * 100) / 100\n  }));\n  return pieChartData;  \n  } catch (error) {\n    console.error(\"An error occurred:\", error);\n    throw error;\n  }\n}\n\n","visualization":"table","visualizationSettings":{"thresholds":[{"id":1,"field":"Status","title":"","isEnabled":true,"rules":[{"id":0,"color":{"Default":"var(--dt-colors-charts-logstatus-none-default, #2c2f3f)"},"comparator":"=","label":"","value":"Completed without errors"},{"id":1,"color":{"Default":"var(--dt-colors-charts-loglevel-emergency-default, #9033a3)"},"comparator":"=","label":"","value":"Failed"},{"id":2,"color":{"Default":"var(--dt-colors-charts-categorical-color-09-default, #649438)"},"comparator":"=","label":"","value":"Running"}]}],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute","groupingThresholdValue":0,"valueType":"relative","showTotalValue":false},"categoryOverrides":{},"categoricalBarChartSettings":{"categoryAxisLabel":"Job","valueAxisLabel":"Duration_in_seconds","tooltipVariant":"single","categoryAxis":"Job","valueAxis":"Duration_in_seconds"},"colorPalette":"log-level","truncationMode":"middle"},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","recordField":"element","autoscale":true,"alignment":"center","colorThresholdTarget":"value"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{"[\"Job\"]":313.3125},"colorThresholdTarget":"background","sortBy":{"columnId":"[\"Duration_in_seconds\"]","direction":"descending"}},"honeycomb":{"shape":"hexagon","legend":"auto","dataMappings":{"value":"Duration_in_seconds"},"displayedFields":["Job"],"colorMode":"color-palette","colorPalette":"blue"},"histogram":{"dataMappings":[{"valueAxis":"Duration_in_seconds","rangeAxis":""}]}},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"8":{"type":"markdown","title":"","content":"---  \n## Other telemetry dataðŸ‘‡  \n---\n"}},"layouts":{"0":{"x":0,"y":2,"w":24,"h":6},"1":{"x":11,"y":16,"w":13,"h":6},"2":{"x":0,"y":14,"w":24,"h":2},"3":{"x":5,"y":16,"w":6,"h":6},"4":{"x":0,"y":16,"w":5,"h":6},"5":{"x":0,"y":0,"w":24,"h":2},"6":{"x":0,"y":8,"w":24,"h":6},"8":{"x":0,"y":22,"w":24,"h":2}},"importedWithCode":true}