{
  "id": "87c8d72c-2a65-4dda-b04b-d919233b4a14",
  "title": "Pull GitLab Pipeline details & push bizevents",
  "tasks": {
    "pull_n_ingest_gitlab_pipeline_metadata": {
      "name": "pull_n_ingest_gitlab_pipeline_metadata",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { execution } from '@dynatrace-sdk/automation-utils';\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport { credentialVaultClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\n// Function to get client-id, client-secret & refresh-token from Dynatrace Credentials Vault\nasync function getCredentialsFromVault(config) {\n  try {\n    const data = await credentialVaultClient.listCredentials(config);\n    if (!data.credentials || data.credentials.length === 0) {\n      throw new Error('No credentials found');\n    }\n    const credentialsUuid = data.credentials[0].id;\n    return await credentialVaultClient.getCredentialsDetails({ id: credentialsUuid });\n  } catch (error) {\n    console.error(`Error fetching credentials: ${error.message}`);\n    throw error;\n  }\n}\n\n/* Function to get pipeline details */\nasync function getPipelineDetails(gitlabBaseUrl, GITLAB_TOKEN, projectId, pipelineId) {\n  const pipelineResponse = await fetch(`${gitlabBaseUrl}/api/v4/projects/${projectId}/pipelines/${pipelineId}`, {\n    headers: {\n      'Authorization': `Bearer ${GITLAB_TOKEN}`,\n    },\n  });\n\n  if (!pipelineResponse.ok) {\n    console.error(`Failed to fetch pipeline details for pipeline ${pipelineId}`);\n    return null;\n  }\n\n  return await pipelineResponse.json();\n}\n\n/* Function to get MergeRequestCycleTime details */\nasync function getMergeRequestCycleTime(gitlabBaseUrl, GITLAB_TOKEN, projectId) {\n  const mergeRequestsResponse = await fetch(`${gitlabBaseUrl}/api/v4/projects/${projectId}/merge_requests?state=merged&created_after=${new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()}`, {\n    headers: {\n      'Authorization': `Bearer ${GITLAB_TOKEN}`,\n    },\n  });\n\n  if (!mergeRequestsResponse.ok) {\n    console.error(`Failed to fetch merge requests for project ${projectId}`);\n    return null;\n  }\n\n  const mergeRequests = await mergeRequestsResponse.json();\n  let totalCycleTime = 0;\n  let count = 0;\n\n  for (let i = 0; i < mergeRequests.length; i++) {\n    const mr = mergeRequests[i];\n    const createdAt = new Date(mr.created_at);\n    const mergedAt = new Date(mr.merged_at);\n    const cycleTime = (mergedAt - createdAt) / (1000 * 60 * 60); // in hours\n    totalCycleTime += cycleTime;\n    count++;\n  }\n\n  return count > 0 ? totalCycleTime / count : 0;\n}\n\n/* Function to get RepositoryStorageUsage */\nasync function getRepositoryStorageUsage(gitlabBaseUrl, GITLAB_TOKEN, projectId) {\n  const projectResponse = await fetch(`${gitlabBaseUrl}/api/v4/projects/${projectId}`, {\n    headers: {\n      'Authorization': `Bearer ${GITLAB_TOKEN}`,\n    },\n  });\n\n  if (!projectResponse.ok) {\n    console.error(`Failed to fetch project details for project ${projectId}`);\n    return null;\n  }\n\n  const projectDetails = await projectResponse.json();\n  return projectDetails.statistics?.repository_size;\n}\n\n/* Get the activeContributorslist from Gitlab */\nasync function getActiveContributors(gitlabBaseUrl, GITLAB_TOKEN, projectId) {\n  const contributorsResponse = await fetch(`${gitlabBaseUrl}/api/v4/projects/${projectId}/repository/contributors`, {\n    headers: {\n      'Authorization': `Bearer ${GITLAB_TOKEN}`,\n    },\n  });\n\n  if (!contributorsResponse.ok) {\n    console.error(`Failed to fetch contributors for project ${projectId}`);\n    return null;\n  }\n\n  const contributors = await contributorsResponse.json();\n  return contributors.length;\n}\n\n/* Main function */\nexport default async function ({ execution_id }) {\n  var gitlabBaseUrl = \"https://gitlab.com/\";\n  var gitlab_credentials = await getCredentialsFromVault({\"name\":\"Gitlab-credential\"});\n  var GITLAB_TOKEN = gitlab_credentials.token;\n  console.log(GITLAB_TOKEN);\n\n  var page = 1;\n  var allProjects = [];\n\n  while (true) {\n    const projectsResponse = await fetch(`${gitlabBaseUrl}/api/v4/projects?membership=true&page=${page}&per_page=100`, {\n      headers: {\n        'Authorization': `Bearer ${GITLAB_TOKEN}`,\n      },\n    });\n\n    if (!projectsResponse.ok) {\n      const projectsResponseText = await projectsResponse.text();\n      throw new Error(`Failed to fetch GitLab projects. Response status: ${projectsResponse.status}. Response text: ${projectsResponseText}`);\n    }\n\n    const projects = await projectsResponse.json();\n    if (projects.length === 0) {\n      break;\n    }\n\n    allProjects = allProjects.concat(projects);\n    page++;\n\n    await new Promise(function(resolve) { setTimeout(resolve, 1000); });\n  }\n\n  console.log(`Total projects fetched: ${allProjects.length}`);\n\n  for (let i = 0; i < allProjects.length; i++) {\n    const project = allProjects[i];\n    console.log(`Processing project: ${project.name}`);\n\n    try {\n      const [mergeRequestCycleTime, repositoryStorageUsage, activeContributors, pipelinesData] = await Promise.all([\n        getMergeRequestCycleTime(gitlabBaseUrl, GITLAB_TOKEN, project.id),\n        getRepositoryStorageUsage(gitlabBaseUrl, GITLAB_TOKEN, project.id),\n        getActiveContributors(gitlabBaseUrl, GITLAB_TOKEN, project.id),\n        fetch(`${gitlabBaseUrl}/api/v4/projects/${project.id}/pipelines`, {\n          headers: {\n            'Authorization': `Bearer ${GITLAB_TOKEN}`,\n          },\n        }).then(function(res) { return res.json(); })\n      ]);\n\n      const projectMetricsEvent = {\n        \"event.provider\": \"gitlabMetrics\",\n        \"event.type\": \"projectMetrics\",\n        \"project-id\": project.id,\n        \"project-name\": project.name,\n        \"merge-request-cycle-time\": mergeRequestCycleTime,\n        \"repository-storage-usage\": repositoryStorageUsage,\n        \"active-contributors\": activeContributors,\n      };\n\n      await businessEventsClient.ingest({\n        body: projectMetricsEvent,\n        type: 'application/json',\n      });\n      console.log(`Project metrics ingested for project ${project.name}`);\n\n      await processPipelines(pipelinesData, gitlabBaseUrl, GITLAB_TOKEN, project.id, project.name);\n\n    } catch (error) {\n      console.error(`Error processing project ${project.name}:`, error);\n    }\n\n    await new Promise(function(resolve) { setTimeout(resolve, 1000); });\n  }\n}\n\n/* Forming pipeline metric JSON object (could be modified to general metric ingestion instead of bizevents) */\nasync function processPipelines(pipelinesData, gitlabBaseUrl, GITLAB_TOKEN, projectId, projectName) {\n  var startTimeEpoch = Date.now() - 240 * 60 * 1000; // Last 240 minutes\n  var endTimeEpoch = Date.now();\n\n  for (let i = 0; i < pipelinesData.length; i++) {\n    const pipeline = pipelinesData[i];\n    console.log(\"Checking pipeline number\",pipeline);\n    var pipelineTimestampEpoch = new Date(pipeline.created_at).getTime();\n    if (pipelineTimestampEpoch >= startTimeEpoch && pipelineTimestampEpoch <= endTimeEpoch) {\n      const pipelineDetails = await getPipelineDetails(gitlabBaseUrl, GITLAB_TOKEN, projectId, pipeline.id);\n      if (pipelineDetails) {\n        await processPipelineAndJobs(pipelineDetails, gitlabBaseUrl, GITLAB_TOKEN, projectId, projectName);\n\n        const pipelineMetrics = {\n          \"event.provider\": \"gitlabMetrics\",\n          \"event.type\": \"pipelineMetrics\",\n          \"project-id\": projectId,\n          \"project-name\": projectName,\n          \"pipeline-id\": pipelineDetails.id,\n          \"pipeline-number\": pipelineDetails.iid,\n          \"pipeline-status\": pipelineDetails.status,\n          \"pipeline-duration\": pipelineDetails.duration || 0,\n          \"pipeline-created_at\": pipelineDetails.created_at,\n          \"pipeline-updated_at\": pipelineDetails.updated_at,\n        };\n\n        //console.log(pipelineMetrics);\n        await businessEventsClient.ingest({\n          body: pipelineMetrics,\n          type: 'application/json',\n        });\n        console.log(`Pipeline metrics ingested for pipeline ${pipelineDetails.id} in project ${projectName}`);\n      }\n    }\n  }\n}\n\n/* Function to populate pipeline details */\nasync function processPipelineAndJobs(pipelineDetails, gitlabBaseUrl, GITLAB_TOKEN, projectId, projectName) {\n  console.log(`Processing pipeline ${pipelineDetails.id} in project ${projectName}`);\n\n  var pipelineStartTime = new Date(pipelineDetails.created_at);\n  var pipelineEndTime = pipelineDetails.finished_at ? new Date(pipelineDetails.finished_at) : new Date();\n  var pipelineDuration = (pipelineEndTime - pipelineStartTime) / 1000; // Duration in seconds\n\n  const pipelineEvent = {\n    \"event.provider\": \"gitlabPipeline\",\n    \"event.type\": \"pipeline\",\n    \"project-id\": projectId,\n    \"project-name\": projectName,\n    \"pipeline-id\": pipelineDetails.id,\n    \"pipeline-number\": pipelineDetails.iid,\n    \"pipeline-ref\": pipelineDetails.ref,\n    \"pipeline-status\": pipelineDetails.status,\n    \"pipeline-created_at\": pipelineDetails.created_at,\n    \"pipeline-started_at\": pipelineDetails.started_at || pipelineDetails.created_at,\n    \"pipeline-finished_at\": pipelineDetails.finished_at || null,\n    \"pipeline-duration\": pipelineDuration,\n    \"pipeline-updated_at\": pipelineDetails.updated_at,\n    \"pipeline-triggered_by\": pipelineDetails.user ? pipelineDetails.user.name : \"Unknown\",\n    \"pipeline-triggered_by_username\": pipelineDetails.user ? pipelineDetails.user.username : \"Unknown\",\n  };\n\n  await businessEventsClient.ingest({\n    body: pipelineEvent,\n    type: 'application/json',\n  });\n  console.log(`Pipeline event ingested for pipeline ${pipelineDetails.id} in project ${projectName}`);\n\n  const jobsResponse = await fetch(`${gitlabBaseUrl}/api/v4/projects/${projectId}/pipelines/${pipelineDetails.id}/jobs`, {\n    headers: {\n      'Authorization': `Bearer ${GITLAB_TOKEN}`,\n    },\n  });\n\n  if (!jobsResponse.ok) {\n    console.error(`Failed to fetch jobs for pipeline ${pipelineDetails.id}`);\n    return;\n  }\n\n  const jobs = await jobsResponse.json();\n\n  for (let i = 0; i < jobs.length; i++) {\n    const job = jobs[i];\n    await processJob(job, pipelineDetails, projectName, projectId);\n  }\n}\n\nasync function processJob(job, pipelineDetails, projectName, projectId) {\n  var jobStartTime = new Date(job.created_at);\n  var jobEndTime = job.finished_at ? new Date(job.finished_at) : new Date();\n  var jobDuration = (jobEndTime - jobStartTime) / 1000; // Duration in seconds\n\n  const jobEvent = {\n    \"event.provider\": \"gitlabJob\",\n    \"event.type\": \"job\",\n    \"project-id\": projectId,\n    \"project-name\": projectName,\n    \"pipeline-id\": pipelineDetails.id,\n    \"pipeline-number\": pipelineDetails.iid,\n    \"pipeline-status\": pipelineDetails.status,\n    \"job-id\": job.id,\n    \"job-name\": job.name,\n    \"job-status\": job.status,\n    \"job-created_at\": job.created_at,\n    \"job-started_at\": job.started_at || job.created_at,\n    \"job-finished_at\": job.finished_at || null,\n    \"job-duration\": jobDuration,\n    \"job-stage\": job.stage,\n  };\n\n  await businessEventsClient.ingest({\n    body: jobEvent,\n    type: 'application/json',\n  });\n  console.log(`Job event ingested for job ${job.id} in pipeline ${pipelineDetails.id} and project ${projectName}`);\n}\n"
      },
      "active": true,
      "position": {
        "x": 0,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    }
  },
  "description": "",
  "actor": "56950d1e-d9e8-4c6f-9c70-46b093c4434d",
  "owner": "56950d1e-d9e8-4c6f-9c70-46b093c4434d",
  "ownerType": "USER",
  "isPrivate": true,
  "trigger": {
    "schedule": {
      "isActive": true,
      "isFaulty": false,
      "trigger": {
        "type": "interval",
        "intervalMinutes": 60
      },
      "rule": null,
      "filterParameters": {
        "earliestStart": "2024-04-18",
        "earliestStartTime": "00:00"
      },
      "timezone": "Australia/Sydney",
      "inputs": {},
      "nextExecution": "2024-10-25T12:00:00.000Z"
    }
  },
  "schemaVersion": 3
}